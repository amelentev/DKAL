%{
open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Globals
open Microsoft.Research.Dkal.Ast.Infon
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.SqlSubstrate
open Microsoft.Research.Dkal.Substrate.Factories

open System
open System.Collections.Generic
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start ITerm
%start Type

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Delimiters
%token LPAR RPAR COMMA 

// Types
%token COLON TIMES TO

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Substrate expressions
%token <System.String * System.String> SUBSTRATE_EXPRESSION

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < ITerm > ITerm
%type < IType > Type

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

ITerm:
	| LOWER_IDENTIFIER COLON Types TO Type LPAR ITerms RPAR			
    { let types = $3 : IType list
      if types.Length > 0 then
        match SqlPrimitives.SolveOverloadOperator $1 types.[0] with
        | Some f -> App(f, $7) 
        | None -> App({ Name = $1; ArgsType = $3; RetType = $5; Identity = None }, $7) 
      else
        App({ Name = $1; ArgsType = $3; RetType = $5; Identity = None }, $7) } 
	| Literal														                        { Const($1) }
	| UPPER_IDENTIFIER COLON Type							              		{ Var({ Name = $1; Type = $3 }) }
	| LPAR ITerm RPAR										                    		{ $2 }
  | SUBSTRATE_EXPRESSION
    { let ns, exp = $1;
      let substrate = SubstrateMap.GetSubstrate ns;
      let parser = SubstrateParserFactory.SubstrateParser substrate "typed" ns 0 (new Dictionary<_,_>()) (new Dictionary<_,_>());
      parser.ParseTerm exp :> ITerm }

ITerms:
	|										          	{ [] }
	| ITerm									      	{ [$1] }
	| ITerm COMMA ITerms						{ $1 :: $3 }

Literal:
	| TRUE										{ SubstrateConstant(true) :> Constant }
	| FALSE										{ SubstrateConstant(false) :> Constant }
	| INT_LITERAL							{ SubstrateConstant($1) :> Constant }
	| FLOAT_LITERAL						{ SubstrateConstant($1) :> Constant }
	| STRING_LITERAL					{ SubstrateConstant($1) :> Constant }
	| LOWER_IDENTIFIER				{ PrincipalConstant($1) :> Constant }

Type:
	| UPPER_IDENTIFIER				{ Type.FromFullName $1 }

Types:
	|									      	{ [] }
	| Type									  { [$1] }
	| Type TIMES Types				{ $1 :: $3 }
