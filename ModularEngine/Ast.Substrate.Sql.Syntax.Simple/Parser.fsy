%{
open Microsoft.Research.Dkal.Ast.Substrate.Sql.Syntax.Simple.SimpleAst
open Microsoft.Research.Dkal.Substrate.Sql

open System
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start MetaTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Binary operators
%token AND OR IMPLIES 
%token EQ NEQ LT GT 
%token PLUS MINUS TIMES DIV

// Unary operators
%token NOT

// Delimiters
%token LPAR RPAR LBRACE RBRACE LSQ RSQ COLON SEMICOLON COMMA DOT PIPE GETS

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Substrate expressions
%token <System.String * System.String> SUBSTRATE_EXPRESSION

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < SimpleMetaTerm > MetaTerm

// ------------------------------------------------------------------------------------------------------
// Precedence of operators

%left IMPLIES
%left OR
%left AND
%left EQ NEQ LT LTE GT GTE 
%left PLUS MINUS
%left TIMES DIV

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

MetaTerm:
  | Term EOF                                       { $1 }
  | Term PIPE ColUpdates EOF                       { SimpleModify($1, $3) }

Term:
// Tables, relations and function/macro calls
	| LOWER_IDENTIFIER LPAR Terms RPAR	    	    { SimpleApp($1, $3) }
	| LOWER_IDENTIFIER DOT LOWER_IDENTIFIER       { SimpleApp($1 + "." + $3, []) }

// Bool constructs
	| SUBSTRATE_EXPRESSION              { SimpleSubstrate($1) }
  | Term AND Term					          	{ SimpleApp(SqlPrimitives.And, [$1; $3]) }
	| Term OR Term					          	{ SimpleApp(SqlPrimitives.Or, [$1; $3]) }
	| NOT Term							            { SimpleApp(SqlPrimitives.Not, [$2]) }
	| Term EQ EQ Term		%prec EQ	      { SimpleApp(SqlPrimitives.Eq, [$1; $4]) }
	| Term NOT EQ Term		%prec EQ	    { SimpleApp(SqlPrimitives.Neq, [$1; $4]) }
	| Term LT Term					          	{ SimpleApp(SqlPrimitives.Lt, [$1; $3]) }
	| Term LT EQ Term		%prec EQ	      { SimpleApp(SqlPrimitives.Lte, [$1; $4]) }
	| Term GT Term					          	{ SimpleApp(SqlPrimitives.Gt, [$1; $3]) }
	| Term GT EQ Term		%prec EQ	      { SimpleApp(SqlPrimitives.Gte, [$1; $4]) }

// Arithmetic
	| Term PLUS Term					  { SimpleApp(SqlPrimitives.Plus, [$1; $3]) }
	| Term MINUS Term				  	{ SimpleApp(SqlPrimitives.Minus, [$1; $3]) }
	| MINUS Term %prec TIMES		{ SimpleApp(SqlPrimitives.Uminus, [$2]) } 
	| Term TIMES Term					  { SimpleApp(SqlPrimitives.Times, [$1; $3]) }
	| Term DIV Term					  	{ SimpleApp(SqlPrimitives.Divide, [$1; $3]) }

// Constants, variables, misc
	| Literal							      		{ SimpleConst($1) }
	| UPPER_IDENTIFIER							{ SimpleVar($1) }
	| LPAR Term RPAR			      		{ $2 }

Terms:
	|									         	{ [] }
	| Term								    	{ [$1] }
	| Term COMMA Terms    			{ $1 :: $3 }

Literal:
	| TRUE								    		{ BoolSimpleConstant(true) }
	| FALSE									    	{ BoolSimpleConstant(false) }
	| INT_LITERAL								  { Int32SimpleConstant($1) }
	| FLOAT_LITERAL								{ DoubleSimpleConstant($1) }
	| STRING_LITERAL							{ StringSimpleConstant($1) }
	| LOWER_IDENTIFIER						{ PrincipalSimpleConstant($1) }

ColUpdate:
  | LOWER_IDENTIFIER DOT LOWER_IDENTIFIER GETS Term              { ($1 + "." + $3, $5) }

ColUpdates:
  | ColUpdate                   { [$1] }
  | ColUpdate COMMA ColUpdates  { $1 :: $3 }