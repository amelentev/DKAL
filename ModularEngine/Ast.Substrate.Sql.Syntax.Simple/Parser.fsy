%{
open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Globals
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Substrate
open Microsoft.Research.Dkal.Substrate.Sql
open Microsoft.Research.Dkal.Substrate.Factories

open System
open System.Collections.Generic

let mutable ctx : IParsingContext option = None
let mutable substrate: SqlSubstrate option = None
let mutable ns : string = null

let solvedMacros = new List<ISubstrateQueryTerm>()

let splitTableCol (tableCol: string) =
  match tableCol.Split [|'.'|] with
  | [| table; column |] -> 
    table, column
  | _ -> failwithf "Incorrect table.column operator usage in %O" tableCol

let primitiveApp (f: string, args: ITerm list) = 
  match SqlPrimitives.SolveOverloadOperator f args.[0].Type with
  | Some(f) -> 
    App(f, args)
  | None ->
    failwithf "Unknown SQL function %O for arguments %O" f args

let queryWithMacros t = 
  let termWithMacros = AndBool((Seq.toList (Seq.map AsBoolean solvedMacros)) @ [t])
  solvedMacros.Clear()
  termWithMacros.Normalize()

%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start SubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Binary operators
%token AND OR IMPLIES 
%token EQ NEQ LT GT 
%token PLUS MINUS TIMES DIV

// Unary operators
%token NOT

// Delimiters
%token LPAR RPAR LBRACE RBRACE LSQ RSQ COLON SEMICOLON COMMA DOT PIPE GETS

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Substrate expressions
%token <System.String * System.String> SUBSTRATE_EXPRESSION

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < ISubstrateTerm > SubstrateTerm

// ------------------------------------------------------------------------------------------------------
// Precedence of operators

%left IMPLIES
%left OR
%left AND
%left EQ NEQ LT LTE GT GTE 
%left PLUS MINUS
%left TIMES DIV

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

SubstrateTerm:
  | Term EOF                                       
    { new DummySubstrateQueryTerm(queryWithMacros $1, ns) :> ISubstrateTerm }
  | Term PIPE ColUpdates EOF                       
    { let colsMapping = new Dictionary<string, ITerm>()
      for (tableCol, t) in $3 do
        // TODO if not(macros.IsEmpty) then
          // failwith "Unresolved macros inside SQL modify statement"
        colsMapping.[tableCol] <- t
      SqlSubstrateModifyTerm(ns, queryWithMacros $1, colsMapping) :> ISubstrateTerm }

Term:
// Tables and function/macro calls
	| LOWER_IDENTIFIER DOT LOWER_IDENTIFIER 
    { let typ = Type.Substrate(substrate.Value.GetColumnType $1 $3)
      App({Name=$1+"."+$3; RetType=typ; ArgsType=[]; Identity=None}, []) }

	| LOWER_IDENTIFIER LPAR Terms RPAR	    	    
    { let concreteArgs: ITerm list = $3
      if ctx.Value.HasMacro $1 then
        // it is a macro
        let ret, solvedMacro = ctx.Value.ApplyMacro($1, concreteArgs)
        solvedMacros.Add solvedMacro |> ignore
        ret
      elif concreteArgs.Length > 0 then
        // it is an overloaded operator
        primitiveApp($1, $3) 
      else
        failwithf "Unknown or malformed function application in %O(%O)" $1 $3 }

// Nested substrates
	| SUBSTRATE_EXPRESSION              
    { let ns, exp = $1
      let substrate = SubstrateMap.GetSubstrate ns
      let parser = SubstrateParserFactory.SubstrateParser substrate "simple" ns ctx
      parser.ParseTerm exp :> ITerm }

// Bool constructs
  | Term AND Term					          	{ primitiveApp(SqlPrimitives.And, [$1; $3]) }
	| Term OR Term					          	{ primitiveApp(SqlPrimitives.Or, [$1; $3]) }
	| NOT Term							            { primitiveApp(SqlPrimitives.Not, [$2]) }
	| Term EQ EQ Term		%prec EQ	      { primitiveApp(SqlPrimitives.Eq, [$1; $4]) }
	| Term NOT EQ Term		%prec EQ	    { primitiveApp(SqlPrimitives.Neq, [$1; $4]) }
	| Term LT Term					          	{ primitiveApp(SqlPrimitives.Lt, [$1; $3]) }
	| Term LT EQ Term		%prec EQ	      { primitiveApp(SqlPrimitives.Lte, [$1; $4]) }
	| Term GT Term					          	{ primitiveApp(SqlPrimitives.Gt, [$1; $3]) }
	| Term GT EQ Term		%prec EQ	      { primitiveApp(SqlPrimitives.Gte, [$1; $4]) }

// Arithmetic
	| Term PLUS Term					  { primitiveApp(SqlPrimitives.Plus, [$1; $3]) }
	| Term MINUS Term				  	{ primitiveApp(SqlPrimitives.Minus, [$1; $3]) }
	| MINUS Term %prec TIMES		{ primitiveApp(SqlPrimitives.Uminus, [$2]) } 
	| Term TIMES Term					  { primitiveApp(SqlPrimitives.Times, [$1; $3]) }
	| Term DIV Term					  	{ primitiveApp(SqlPrimitives.Divide, [$1; $3]) }

// Constants, variables, misc
	| Literal							      		{ $1 }
	| Variable        							{ $1 }
	| LPAR Term RPAR			      		{ $2 }

Terms:
	|									         	{ [] }
	| Term								    	{ [$1] }
	| Term COMMA Terms    			{ $1 :: $3 }

Variable:
  | UPPER_IDENTIFIER 
    { if $1 = "Me" then
        Const <| PrincipalConstant(ctx.Value.Me)
      else
        Var({ Name = $1; Type = ctx.Value.VariableType $1 }) }

Literal:
	| TRUE									    	{ Const(Constant(true)) }
	| FALSE									    	{ Const(Constant(false)) }
	| INT_LITERAL						  		{ Const(Constant($1)) }
	| FLOAT_LITERAL								{ Const(Constant($1)) }
	| STRING_LITERAL							{ Const(Constant($1)) }
	| LOWER_IDENTIFIER						{ Const(PrincipalConstant($1)) }

ColUpdate:
  | LOWER_IDENTIFIER DOT LOWER_IDENTIFIER GETS Term              { ($1 + "." + $3, $5) }

ColUpdates:
  | ColUpdate                   { [$1] }
  | ColUpdate COMMA ColUpdates  { $1 :: $3 }