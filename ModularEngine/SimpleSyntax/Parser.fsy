%{
open Microsoft.Research.Dkal.SimpleSyntax.SimpleAst

open System
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start Assembly
%start Signature
%start Policy
%start TypeDeclaration
%start TableDeclaration
%start RelationDeclaration
%start FunctionDeclaration
%start Assertion
%start Infon
%start Term

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Binary operators
%token AND OR IMPLIES 
%token EQ NEQ LT GT 
%token PLUS MINUS TIMES DIV

// Unary operators
%token AS_INFON SAID NOT

// Delimiters
%token LPAR RPAR LBRACE RBRACE COLON COMMA DOT

// Type renames
%token TYPE

// Table declarations
%token TABLE

// Relation declarations
%token RELATION

// Function declarations
%token FUNCTION

// Variable declarations
%token WITH

// Assertions
%token ME KNOWS IF SEND TO

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < SimpleAssembly > Assembly
%type < SimpleSignature > Signature
%type < SimplePolicy > Policy
%type < SimpleTypeDeclaration > TypeDeclaration
%type < SimpleTableDeclaration > TableDeclaration
%type < SimpleRelationDeclaration > RelationDeclaration
%type < SimpleFunctionDeclaration > FunctionDeclaration
%type < SimpleAssertion > Assertion
%type < SimpleMetaTerm > Infon
%type < SimpleMetaTerm > Term

// ------------------------------------------------------------------------------------------------------
// Precedence of operators

%left IMPLIES
%right SAID
%left OR
%left AND
%left EQ NEQ LT LTE GT GTE 
%left PLUS MINUS
%left TIMES DIV

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

Assembly:
	| Signature Policy							{ { Signature = $1; Policy = $2 } }

Signature:
	|											{ SimpleSignature() }
	| Signature TypeDeclaration 				{ $1.TypeDeclarations.Add($2); $1 }
	| Signature TableDeclaration 				{ $1.TableDeclarations.Add($2); $1 }
	| Signature RelationDeclaration 			{ $1.RelationDeclarations.Add($2); $1 }
	| Signature FunctionDeclaration 			{ $1.FunctionDeclarations.Add($2); $1 }

Policy:
	|											{ SimplePolicy() }
	| Policy Assertion							{ $1.Assertions.Add($2); $1 }

TypeDeclaration:
	| TYPE Type EQ Type							{ { newTyp = $2; targetTyp = $4 } }

TableDeclaration:
	| TABLE LOWER_IDENTIFIER LPAR Cols RPAR		{ { Name = $2; Cols = $4 } }

Cols:
	|											{ [] }
	| Col										{ [$1] }
	| Col COMMA Cols							{ $1 :: $3 }

Col:
	| LOWER_IDENTIFIER COLON Type				{ ($1, $3) }

RelationDeclaration:
	| RELATION LOWER_IDENTIFIER LPAR Args RPAR		{ { Name = $2; Args = $4 } }   

Args:
	|											{ [] }
	| Arg										{ [$1] }
	| Arg COMMA Args							{ $1 :: $3 }

Arg:
	| UPPER_IDENTIFIER COLON Type				{ ($1, $3) }

Type:
	| LOWER_IDENTIFIER							{ $1 }

FunctionDeclaration:
	| FUNCTION LOWER_IDENTIFIER LPAR Args RPAR 
		COLON Type LBRACE Expression RBRACE			{ { Name = $2; Args = $4; RetTyp = $7; Body = $9 } }

Expression:
	| Term										{ $1 }
	| LOWER_IDENTIFIER DOT LOWER_IDENTIFIER		{ SimpleApp($1 + "." + $3, []) }
	| Expression AND Expression					{ SimpleApp("boolAnd", [$1; $3]) }
	| Expression OR Expression					{ SimpleApp("boolOr", [$1; $3]) }
	| NOT Expression							{ SimpleApp("boolNot", [$2]) }
	| Expression EQ EQ Expression				{ SimpleApp("eq", [$1; $4]) }
	| Expression NOT EQ Expression				{ SimpleApp("neq", [$1; $4]) }
	| Expression LT Expression					{ SimpleApp("lt", [$1; $3]) }
	| Expression LT EQ Expression				{ SimpleApp("lte", [$1; $4]) }
	| Expression GT Expression					{ SimpleApp("gt", [$1; $3]) }
	| Expression GT EQ Expression				{ SimpleApp("gte", [$1; $4]) }
	| Expression PLUS Expression				{ SimpleApp("plus", [$1; $3]) }
	| Expression MINUS Expression				{ SimpleApp("minus", [$1; $3]) }
	| MINUS Expression							{ SimpleApp("uminus", [$2]) }
	| Expression TIMES Expression				{ SimpleApp("times", [$1; $3]) }
	| Expression DIV Expression					{ SimpleApp("divide", [$1; $3]) }
	| LPAR Expression RPAR						{ $2 }

Assertion:
	| WITH Args ME KNOWS Infon					{ SimpleKnow({ Args = $2; Fact = $5 }) }
	| ME KNOWS Infon							{ SimpleKnow({ Args = []; Fact = $3 }) }
	| WITH Args IF Infon SEND TO Term Infon		{ SimpleCommRule({ Args = $2; Trigger = $4; Target = $7; Content = $8 }) }
	| IF Infon SEND TO Term Infon				{ SimpleCommRule({ Args = []; Trigger = $2; Target = $5; Content = $6 }) }

Infon:
	| AS_INFON LPAR Expression RPAR				{ SimpleApp("asInfon", [$3]) }
	| LOWER_IDENTIFIER LPAR Terms RPAR			{ SimpleApp($1, $3) }
	| Infon AND Infon							{ SimpleApp("infonAnd", [$1; $3]) }
	| Infon IMPLIES Infon						{ SimpleApp("infonImplies", [$1; $3]) }
	| Term SAID Infon							{ SimpleApp("infonSaid", [$1; $3]) }
	| LPAR Infon RPAR							{ $2 }

Terms:
	|											{ [] }
	| Term										{ [$1] }
	| Term COMMA Terms							{ $1 :: $3 }

Term:
	| Literal									{ SimpleConst($1) }
	| LOWER_IDENTIFIER LPAR Terms RPAR			{ SimpleApp($1, $3) }
	| UPPER_IDENTIFIER							{ SimpleVar($1) }

Literal:
	| TRUE										{ BoolSimpleConstant(true) }
	| FALSE										{ BoolSimpleConstant(false) }
	| INT_LITERAL								{ IntSimpleConstant($1) }
	| FLOAT_LITERAL								{ FloatSimpleConstant($1) }
	| STRING_LITERAL							{ StringSimpleConstant($1) }
	| LOWER_IDENTIFIER							{ PrincipalSimpleConstant($1) }
