%{
open Microsoft.Research.Dkal.SimpleSyntax.SimpleAst

open System

let asInfonTrue = SimpleApp("asInfon", [SimpleConst(BoolSimpleConstant(true))])
let toSimpleMetaTerms args = List.map (fun (name, typ) -> SimpleVar(name + ":" + typ)) args
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start Assembly
%start Signature
%start Policy
%start TypeDeclaration
%start TableDeclaration
%start RelationDeclaration
%start FunctionDeclaration
%start MetaTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Binary operators
%token AND OR IMPLIES 
%token EQ NEQ LT GT 
%token PLUS MINUS TIMES DIV

// Unary operators
%token AS_INFON SAID NOT

// Delimiters
%token LPAR RPAR LBRACE RBRACE COLON SEMICOLON COMMA DOT

// Type renames
%token TYPE

// Table declarations
%token TABLE

// Relation declarations
%token RELATION

// Function declarations
%token FUNCTION

// Variable declarations
%token WITH

// Assertions
%token ME KNOWS IF THEN WIRE HAS

// Actions
%token SEND TO LEARN

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < SimpleAssembly > Assembly
%type < SimpleSignature > Signature
%type < SimplePolicy > Policy
%type < SimpleTypeDeclaration > TypeDeclaration
%type < SimpleTableDeclaration > TableDeclaration
%type < SimpleRelationDeclaration > RelationDeclaration
%type < SimpleFunctionDeclaration > FunctionDeclaration
%type < SimpleMetaTerm > MetaTerm

// ------------------------------------------------------------------------------------------------------
// Precedence of operators

%right SEMICOLON
%left SEND LEARN
%left IMPLIES
%right SAID
%left OR
%left AND
%left EQ NEQ LT LTE GT GTE 
%left PLUS MINUS
%left TIMES DIV

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

Assembly:
	| Signature Policy							{ { Signature = $1; Policy = $2 } }

Signature:
	|											{ SimpleSignature() }
	| Signature TypeDeclaration 				{ $1.TypeDeclarations.Add($2); $1 }
	| Signature TableDeclaration 				{ $1.TableDeclarations.Add($2); $1 }
	| Signature RelationDeclaration 			{ $1.RelationDeclarations.Add($2); $1 }
	| Signature FunctionDeclaration 			{ $1.FunctionDeclarations.Add($2); $1 }

Policy:
	|											{ SimplePolicy() }
	| Policy MetaTerm							{ $1.Rules.Add($2); $1 }

TypeDeclaration:
	| TYPE Type EQ Type							{ { newTyp = $2; targetTyp = $4 } }

TableDeclaration:
	| TABLE LOWER_IDENTIFIER LPAR Cols RPAR		{ { Name = $2; Cols = $4 } }

Cols:
	|											{ [] }
	| Col										{ [$1] }
	| Col COMMA Cols							{ $1 :: $3 }

Col:
	| LOWER_IDENTIFIER COLON Type				{ ($1, $3) }

RelationDeclaration:
	| RELATION LOWER_IDENTIFIER LPAR Args RPAR		{ { Name = $2; Args = $4 } }   

Args:
	|											{ [] }
	| Arg										{ [$1] }
	| Arg COMMA Args							{ $1 :: $3 }

Arg:
	| UPPER_IDENTIFIER COLON Type				{ ($1, $3) }

Type:
	| LOWER_IDENTIFIER							{ $1 }

FunctionDeclaration:
	| FUNCTION LOWER_IDENTIFIER LPAR Args RPAR 
		COLON Type LBRACE MetaTerm RBRACE		{ { Name = $2; Args = $4; RetTyp = $7; Body = $9 } }

MetaTerm:
// Infon constructs
	| AS_INFON LPAR MetaTerm RPAR				{ SimpleApp("asInfon", [$3]) }
	| MetaTerm IMPLIES MetaTerm					{ SimpleApp("impliesInfon", [$1; $3]) }
	| MetaTerm SAID MetaTerm					{ SimpleApp("saidInfon", [$1; $3]) }

// Tables, relations and function/macro calls
	| LOWER_IDENTIFIER LPAR MetaTerms RPAR		{ SimpleApp($1, $3) }
	| LOWER_IDENTIFIER DOT LOWER_IDENTIFIER		{ SimpleApp($1 + "." + $3, []) }

// Generic Infon/Bool constructs
	| MetaTerm AND MetaTerm						{ SimpleApp("and", [$1; $3]) }

// Bool constructs
	| MetaTerm OR MetaTerm						{ SimpleApp("orBool", [$1; $3]) }
	| NOT MetaTerm								{ SimpleApp("notBool", [$2]) }
	| MetaTerm EQ EQ MetaTerm					{ SimpleApp("eq", [$1; $4]) }
	| MetaTerm NOT EQ MetaTerm					{ SimpleApp("neq", [$1; $4]) }
	| MetaTerm LT MetaTerm						{ SimpleApp("lt", [$1; $3]) }
	| MetaTerm LT EQ MetaTerm					{ SimpleApp("lte", [$1; $4]) }
	| MetaTerm GT MetaTerm						{ SimpleApp("gt", [$1; $3]) }
	| MetaTerm GT EQ MetaTerm					{ SimpleApp("gte", [$1; $4]) }

// Arithmetic
	| MetaTerm PLUS MetaTerm					{ SimpleApp("plus", [$1; $3]) }
	| MetaTerm MINUS MetaTerm					{ SimpleApp("minus", [$1; $3]) }
	| MINUS MetaTerm							{ SimpleApp("uminus", [$2]) }
	| MetaTerm TIMES MetaTerm					{ SimpleApp("times", [$1; $3]) }
	| MetaTerm DIV MetaTerm						{ SimpleApp("divide", [$1; $3]) }

// Constants, variables, misc
	| Literal									{ SimpleConst($1) }
	| UPPER_IDENTIFIER							{ SimpleVar($1) }
	| LPAR MetaTerm RPAR						{ $2 }

// Rules
	| WITH Args ME KNOWS MetaTerm										{ SimpleApp("rule", [asInfonTrue; asInfonTrue; SimpleApp("learn", [$5])] @ toSimpleMetaTerms $2) }
	| ME KNOWS MetaTerm													{ SimpleApp("rule", [asInfonTrue; asInfonTrue; SimpleApp("learn", [$3])]) }
	| WITH Args IF ME KNOWS MetaTerm THEN Action						{ SimpleApp("rule", [$6; asInfonTrue; $8] @ toSimpleMetaTerms $2)}
	| IF ME KNOWS MetaTerm THEN Action									{ SimpleApp("rule", [$4; asInfonTrue; $6])}
	| WITH Args IF ME KNOWS MetaTerm WIRE HAS MetaTerm THEN Action		{ SimpleApp("rule", [$6; $9; $11] @ toSimpleMetaTerms $2)}
	| IF ME KNOWS MetaTerm WIRE HAS MetaTerm THEN Action				{ SimpleApp("rule", [$4; $7; $9])}
	| WITH Args IF WIRE HAS MetaTerm THEN Action						{ SimpleApp("rule", [asInfonTrue; $6; $8] @ toSimpleMetaTerms $2)}
	| IF WIRE HAS MetaTerm THEN Action									{ SimpleApp("rule", [asInfonTrue; $4; $6])}

Action:
	| SEND TO MetaTerm MetaTerm			{ SimpleApp("send", [$3; $4]) }
	| LEARN MetaTerm					{ SimpleApp("learn", [$2]) }
	| Action SEMICOLON Action			{ SimpleApp("seq", [$1; $3]) }

MetaTerms:
	|											{ [] }
	| MetaTerm									{ [$1] }
	| MetaTerm COMMA MetaTerms					{ $1 :: $3 }

Literal:
	| TRUE										{ BoolSimpleConstant(true) }
	| FALSE										{ BoolSimpleConstant(false) }
	| INT_LITERAL								{ IntSimpleConstant($1) }
	| FLOAT_LITERAL								{ FloatSimpleConstant($1) }
	| STRING_LITERAL							{ StringSimpleConstant($1) }
	| LOWER_IDENTIFIER							{ PrincipalSimpleConstant($1) }
