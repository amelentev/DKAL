%{
open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Substrate.Xml

open System
open System.Collections.Generic

let mutable Namespace: string = null

%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Delimiters
%token PIPE MAPS COMMA COLON

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < XmlSubstrateQueryTerm > XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

XmlSubstrateTerm:
  | STRING_LITERAL PIPE Outputs PIPE Vars       
    { let outputs = new Dictionary<string,ITerm>() 
      for (term, att) in $3 do
        outputs.[att] <- term
      new XmlSubstrateQueryTerm(Namespace, $1, $5, outputs) }

Outputs:
  | Output                                { [$1] }
  | Output COMMA Outputs                  { $1 :: $3 }

Output:
  | Term MAPS STRING_LITERAL      { ($1, $3) }
  | Term                          { ($1, "") }

Vars:
  |                             { [] }
  | Var                         { [$1] }
  | Var COMMA Vars              { $1 :: $3 }

Var:
  | UPPER_IDENTIFIER COLON Type						              			{ { Name = $1; Type = $3 } :> IVar }

Type:
	| UPPER_IDENTIFIER				{ Type.FromFullName $1 }

Term:
  | Var                         { Var($1) }
  | Literal                     { $1 }

Literal:
	| TRUE									    	{ Const(Constant(true)) }
	| FALSE									    	{ Const(Constant(false)) }
	| INT_LITERAL						  		{ Const(Constant($1)) }
	| FLOAT_LITERAL								{ Const(Constant($1)) }
	| STRING_LITERAL							{ Const(Constant($1)) }
	| LOWER_IDENTIFIER						{ Const(PrincipalConstant($1)) }
