%{
open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Substrate.Xml

open System
open System.Collections.Generic
open System.Text.RegularExpressions

let mutable Context: IParsingContext option = None
let mutable Namespace: string = null

let varsFromQuery (query: string) = 
  let ret = new HashSet<_>()
  let results = Regex.Matches(query, @"\$[A-Z]+([A-Z]|[a-z]|_|[0-9])*\b")
  for result in results do
    let varName = result.Value.Substring(1)
    ret.Add ({Name = varName; Type = Context.Value.VariableType(varName)} :> IVar) |> ignore
  ret |> Seq.toList

%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Delimiters
%token PIPE MAPS COMMA 

// Literals
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < XmlSubstrateQueryTerm > XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

XmlSubstrateTerm:
  | STRING_LITERAL PIPE OutputVars        
    { let outputVars = new Dictionary<string,IVar>() 
      for (varName, att) in $3 do
        outputVars.[att] <- { Name = varName; Type = Context.Value.VariableType(varName) }
      let vars = varsFromQuery($1)
      new XmlSubstrateQueryTerm(Namespace, $1, vars, outputVars) }

OutputVars:
  | OutputVar                               { [$1] }
  | OutputVar COMMA OutputVars              { $1 :: $3 }

OutputVar:
  | UPPER_IDENTIFIER MAPS STRING_LITERAL    { ($1, $3) }
  | UPPER_IDENTIFIER                        { ($1, "") }
