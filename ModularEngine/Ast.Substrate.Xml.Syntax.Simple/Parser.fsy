%{
// *********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//    This code is licensed under the Apache License, Version 2.0.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
// *********************************************************

open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Substrate.Xml

open System
open System.Collections.Generic
open System.Text.RegularExpressions

let mutable Context: IParsingContext option = None
let mutable Namespace: string = null

let replaceMeInQuery (query: string) = 
  (new Regex(@"\$Me\b")).Replace(query, Context.Value.Me)

let varsFromQuery (query: string) = 
  let ret = new HashSet<_>()
  let results = Regex.Matches(query, @"\$[A-Z]+([A-Z]|[a-z]|_|[0-9])*\b")
  for result in results do
    let varName = result.Value.Substring(1)
    ret.Add ({Name = varName; Type = Context.Value.VariableType(varName)} :> IVar) |> ignore
  ret |> Seq.toList

%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Delimiters
%token PIPE MAPS COMMA 

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < XmlSubstrateQueryTerm > XmlSubstrateTerm

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

XmlSubstrateTerm:
  | STRING_LITERAL RightSide EOF    
    { let output = new Dictionary<string,ITerm>() 
      for (term, att) in $2 do
        output.[att] <- term
      let queryWithoutMeVariable = replaceMeInQuery($1)
      let vars = varsFromQuery(queryWithoutMeVariable)
      new XmlSubstrateQueryTerm(Namespace, queryWithoutMeVariable, vars, output) }

RightSide:
  |                                       { [(Var(Context.Value.FreshVar (Type.String)), "")] }
  | PIPE Outputs                          { $2 }

Outputs:
  | Output                                { [$1] }
  | Output COMMA Outputs                  { $1 :: $3 }

Output:
  | Term MAPS STRING_LITERAL    { ($1, $3) } 
  | Term                        { ($1, "") }

Term:
  | Variable                    { Var($1) }
  | Literal                     { $1 }

Variable:
  | UPPER_IDENTIFIER            { {Name=$1; Type=Context.Value.VariableType($1)} }

Literal:
	| TRUE									    	{ Const(Constant(true)) }
	| FALSE									    	{ Const(Constant(false)) }
	| INT_LITERAL						  		{ Const(Constant($1)) }
	| FLOAT_LITERAL								{ Const(Constant($1)) }
	| STRING_LITERAL							{ Const(Constant($1)) }
	| LOWER_IDENTIFIER						{ Const(PrincipalConstant($1)) }
