%{
open Microsoft.Research.Dkal.Interfaces
open Microsoft.Research.Dkal.Globals
open Microsoft.Research.Dkal.Ast
open Microsoft.Research.Dkal.Ast.Tree
open Microsoft.Research.Dkal.Ast.Infon
open Microsoft.Research.Dkal.Ast.Syntax.Parsing
open Microsoft.Research.Dkal.Substrate.Factories

open System
open System.Collections.Generic

let relations = new Dictionary<string, Function>()

let mutable ctxs = new Stack<IParsingContext>()

let solvedMacros = new List<ISubstrateQueryTerm>()

let primitiveApp (f: string, args: ITerm list) = 
  App((Primitives.SolveFunction f).Value, args)
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start Assembly
%start Signature
%start Policy
%start MetaTerm
%start Type

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Binary operators
%token AND IMPLIES 

// Unary operators
%token AS_INFON SAID

// Delimiters
%token EQ LPAR RPAR LBRACE RBRACE LSQ RSQ COLON SEMICOLON COMMA DOT

// Substrate declarations
%token SUBSTRATE NAMESPACES

// Types
%token TYPE 

// Relation declarations
%token RELATION

// Macro declarations
%token MACRO

// Variable declarations
%token WITH

// Rules
%token DO

// Conditions
%token UPON IF

// Actions
%token SEND SAY TO LEARN FORGET INSTALL UNINSTALL APPLY

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Substrate expressions
%token <System.String * System.String> SUBSTRATE_EXPRESSION

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < Assembly > Assembly
%type < Signature > Signature
%type < Policy > Policy
%type < ITerm > MetaTerm
%type < IType > Type

// ------------------------------------------------------------------------------------------------------
// Precedence of operators

%right SEMICOLON
%left SEND LEARN
%left IMPLIES
%right SAID
%left AND

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

Assembly:
	| Signature Policy EOF							  { { Signature = $1; Policy = $2 } }

Signature:
	|										                	{ {Substrates = []; Relations = []} }
	| Signature SubstrateDeclaration 			{ {$1 with Substrates = $1.Substrates @ [$2]} }
	| Signature TypeDeclaration 			  	{ $1 }
	| Signature RelationDeclaration 			{ {$1 with Relations = $1.Relations @ [$2]} }
	| Signature MacroDeclaration 				  { $1 }

Policy:
	|										        	{ {Rules = []} }
	| Policy MetaTerm							{ {$1 with Rules = $1.Rules @ [$2]} }

SubstrateDeclaration:
	| SUBSTRATE LOWER_IDENTIFIER 
		LPAR StringLiterals RPAR	
		NAMESPACES StringLiterals			    	
      { let s = SubstrateFactory.Substrate $2 $4 $7
        SubstrateMap.AddSubstrate s
        s }

TypeDeclaration:
	| TYPE UPPER_IDENTIFIER EQ Type				
    { ctxs.Peek().AddTypeRename($2, $4) }

Cols:
	|										        	{ [] }
	| Col								      		{ [$1] }
	| Col COMMA Cols							{ $1 :: $3 }

Col:
	| LOWER_IDENTIFIER COLON Type				{ ($1, $3) }

RelationDeclaration:
	| RELATION LOWER_IDENTIFIER LPAR Args RPAR		
    { let rel = { Name = $2; ArgsType = (List.map (fun (v:IVar) -> v.Type) $4); RetType = Type.Infon; Identity = None}
      relations.[$2] <- rel
      { Name = $2; Args = $4 } }   

Args:
	|											      { [] }
	| Arg									    	{ [$1] }
	| Arg COMMA Args						{ $1 :: $3 }

Arg:
	| UPPER_IDENTIFIER COLON Type				{ {Name = $1; Type = $3} :> IVar }

Type:
	| UPPER_IDENTIFIER							{ ctxs.Peek().TypeFromName($1) }

MacroDeclaration:
	| MACRO LOWER_IDENTIFIER LPAR Args RPAR 
		COLON Type SUBSTRATE_EXPRESSION 
      { let ns, exp = $8;
        let localContext = new LocalParsingContext($4 @ [{Name="Ret"; Type=$7}], ctxs.Peek())
        let substrate = SubstrateMap.GetSubstrate ns
        let parser = SubstrateParserFactory.SubstrateParser substrate "simple" ns (Some <| (localContext :> IParsingContext))
        match parser.ParseTerm(exp) with
        | :? ISubstrateQueryTerm as body when body.Type = Type.SubstrateQuery ->
          ctxs.Peek().AddMacro($2, $7, body, $4)
        | _ ->
          failwithf "Macro %O body must be substrate query expression, regardless of return type" $2 }

VarsDeclaration:
  | WITH Args
    { ctxs.Push <| new LocalParsingContext($2, ctxs.Peek())}

MetaTerm:
// Variable declarations
  | VarsDeclaration Rule                                    
    { ctxs.Pop() |> ignore
      $2 }

// Infon constructs
	| AS_INFON LPAR TRUE RPAR							  	            { primitiveApp(Primitives.EmptyInfon, []) }
	| AS_INFON LPAR MetaTerm RPAR							            { primitiveApp(Primitives.AsInfon, [$3]) }
	| MetaTerm IMPLIES MetaTerm						            		{ primitiveApp(Primitives.Implies, [$1; $3]) }
	| MetaTerm SAID MetaTerm							              	{ primitiveApp(Primitives.Said, [$1; $3]) }
	| MetaTerm AND MetaTerm							            	  	{ primitiveApp(Primitives.And, [$1; $3]) }

// Relations and function/macro calls
	| LOWER_IDENTIFIER LPAR MetaTerms RPAR		
    { if ctxs.Peek().HasMacro($1) then
        let ret, solvedMacro = ctxs.Peek().ApplyMacro($1, $3)
        solvedMacros.Add solvedMacro |> ignore
        ret
      else
        // check if it is a relation
        let found, func = relations.TryGetValue $1
        if found then
          App(func, $3)
        else
          failwithf "Undefined identifier: %O" $1 }

// Constants, variables, misc
	| Literal							      		{ $1 }
	| Variable        							{ $1 }
	| LPAR MetaTerm RPAR						{ $2 }

// Sequences
//	| LSQ RSQ										                  	{ SimpleApp("nil", []) }
//	| MetaTerm COLON COLON MetaTerm		%prec TIMES		{ SimpleApp("cons", [$1; $4]) }

// Rules
  | Rule                    { $1 }

// Conditions
  | Condition               { $1 }

// Actions
	| Action									{ $1 }

// Substrate expression
  | SUBSTRATE_EXPRESSION    
    { let ns, exp = $1
      let substrate = SubstrateMap.GetSubstrate ns
      let parser = SubstrateParserFactory.SubstrateParser substrate "simple" ns (Some <| ctxs.Peek())
      parser.ParseTerm exp :> ITerm }

Rule:
  | DO Action                          { primitiveApp(Primitives.Rule, [primitiveApp(Primitives.EmptyCondition, []); $2]) }
  | Condition DO Action                { primitiveApp(Primitives.Rule, [$1; $3]) }
  | Rule Rule                          { primitiveApp(Primitives.SeqRule, [$1; $2]) }

Condition:
  | Variable        							    { $1 }
  | UPON MetaTerm                     { primitiveApp(Primitives.WireCondition, [$2]) }
  | IF MetaTerm                       { primitiveApp(Primitives.KnownCondition, [$2]) }
  | Condition Condition               { primitiveApp(Primitives.SeqCondition, [$1; $2]) }

Action:
  | Variable        							      { $1 }
  | SAY TO MetaTerm COLON MetaTerm			{ primitiveApp(Primitives.Say, [$3; $5]) }
	| SEND TO MetaTerm COLON MetaTerm			{ primitiveApp(Primitives.Send, [$3; $5]) }
	| LEARN MetaTerm			      		      { primitiveApp(Primitives.Learn, [$2]) }
	| FORGET MetaTerm				            	{ primitiveApp(Primitives.Forget, [$2]) }
	| INSTALL MetaTerm			    		      { primitiveApp(Primitives.Install, [$2]) }
	| UNINSTALL MetaTerm			    	      { primitiveApp(Primitives.Uninstall, [$2]) }
	| APPLY MetaTerm			    	          { primitiveApp(Primitives.Apply, [$2]) }
	| Action Action		  	                { primitiveApp(Primitives.SeqAction, [$1; $2]) }

MetaTerms:
	|											              { [] }
	| MetaTerm									        { [$1] }
	| MetaTerm COMMA MetaTerms					{ $1 :: $3 }

Variable:
  | UPPER_IDENTIFIER 
    { if $1 = "Me" then
        Const <| PrincipalConstant(ctxs.Peek().Me)
      else
        Var({ Name = $1; Type = ctxs.Peek().VariableType $1 }) }

Literals:
	|									          		{ [] }
	| Literal							      		{ [$1] }
	| Literal COMMA Literals				{ $1 :: $3 }

Literal:
	| TRUE									    	{ Const(Constant(true)) }
	| FALSE									    	{ Const(Constant(false)) }
	| INT_LITERAL						  		{ Const(Constant($1)) }
	| FLOAT_LITERAL								{ Const(Constant($1)) }
	| STRING_LITERAL							{ Const(Constant($1)) }
	| LOWER_IDENTIFIER						{ Const(PrincipalConstant($1)) }

StringLiterals:
	|										                    	{ [] }
	| STRING_LITERAL						            	{ [$1] }
	| STRING_LITERAL COMMA StringLiterals	  	{ $1 :: $3 }
		