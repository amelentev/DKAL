%{
open Microsoft.Research.Dkal.Ast

open System

let parseType (t: string) = 
  match t with
  | "bool" -> Type.Bool
  | "principal" -> Type.Principal
  | "infon" -> Type.Infon
  | "action" -> Type.Action
  | "rule" -> Type.Rule
  | "int" -> Type.Int
  | "float" -> Type.Float
  | "string" -> Type.String
  | t -> failwith <| "Unrecognized type: " + t
%}

// ------------------------------------------------------------------------------------------------------
// The start tokens become parser functions in the compiled code:

%start Policy
%start MetaTerm

// ------------------------------------------------------------------------------------------------------
// These are the terminal tokens of the grammar along with the types of the data carried by each token:

// Delimiters
%token LPAR RPAR COMMA 

// Types
%token COLON TIMES TO

// Literals
%token TRUE FALSE
%token <System.Int32> INT_LITERAL
%token <System.Double> FLOAT_LITERAL
%token <System.String> STRING_LITERAL

// Identifiers
%token <System.String> LOWER_IDENTIFIER UPPER_IDENTIFIER

// EOF
%token EOF

// ------------------------------------------------------------------------------------------------------
// This is the type of the data produced by successful reductions of each 'start' symbol:

%type < Policy > Policy
%type < MetaTerm > MetaTerm

// ------------------------------------------------------------------------------------------------------
// These are the rules of the grammar 

%%

Policy:
	|											{ { Rules = [] } }
	| Policy MetaTerm							{ { Rules = $1.Rules @ [$2] } }

MetaTerm:
	| LOWER_IDENTIFIER COLON Types TO Type LPAR MetaTerms RPAR		{ App({ Name = $1; ArgsTyp = $3; RetTyp = $5 }, $7) }
	| Literal														{ Const($1) }
	| UPPER_IDENTIFIER COLON Type									{ Var({ Name = $1; Typ = $3 }) }
	| LPAR MetaTerm RPAR											{ $2 }

MetaTerms:
	|											{ [] }
	| MetaTerm									{ [$1] }
	| MetaTerm COMMA MetaTerms					{ $1 :: $3 }

Literal:
	| TRUE										{ BoolConstant(true) }
	| FALSE										{ BoolConstant(false) }
	| INT_LITERAL								{ SubstrateElemConstant($1) }
	| FLOAT_LITERAL								{ SubstrateElemConstant($1) }
	| STRING_LITERAL							{ SubstrateElemConstant($1) }
	| LOWER_IDENTIFIER							{ PrincipalConstant($1) }

Type:
	| LOWER_IDENTIFIER							{ parseType($1) }

Types:
	|											{ [] }
	| Type										{ [$1] }
	| Type TIMES Types							{ $1 :: $3 }
