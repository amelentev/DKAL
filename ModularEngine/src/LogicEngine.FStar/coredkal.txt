Core DKAL, i.e., DKAL minus substrate updates ... 

  Constants c ::= tt | ff | p | s 

  Variables x

  Sub query q ::= R i1 ... ik

  Types     t ::= Boolean 
               | Infon 
               | Principal 
               | SubQuery 
               | Evidence

  Evidence  e ::= EmptyEv | SigEv | MPEv | AndEv | AsInfonEv 

  Infons   i,j ::= x 
               | c 
               | Empty
               | AsInfon q
               | And i j
               | Implies i j
               | Said i j
               | forall (x:t). i  <---- Explicit quantifiers in this version
               | Justified i j    <---- It's in the impl, but not in the formalization

  Infostrate K ::= . | i, K 

  Substrate  S ::= . | (R c1 .. cn) | S, S' 

  Var decl   G ::= . | x:t | G, G'

  Prefix  pref ::= hole | Said p pref

--------------------------------------------------------------------------------

                __________
               |          |
               | G |- u:t |  Well-typed terms
               |__________| 

   ----------------------- 
     G, x:t, G' |- x:t
                           
(*
??? What about name clashes?? I suggest two rules instead:						   

   ----------------
     G, x:t |- x:t
	 
	 G |- x:t    x != y
   ---------------------
     G, y:t' |- x:t
*)

   --------------------
     G |- tt:Boolean

   --------------------
     G |- ff:Boolean

     G |- i:Infon    G |- j:Infon
   --------------------------------
      G |- AndInfon i j : Infon
	
     G |- i:Infon    G |- j:Infon
   --------------------------------
      G |- ImpliesInfon i j : Infon
	  
   --------------------
     G |- p:Principal

   --------------------
     G |- Empty:Infon


     G |- q:SubQuery        <--- Base cases for subquery?
   --------------------
     G |- AsInfon q:Infon


     G |- p: Principal
     G |- i: Infon
   --------------------
     G |- Said p i:Infon


     G |- i: Infon
     G |- e: Evidence    <-------- Base cases?
   --------------------
     G |- Justified i e:Infon


     G,x:t |- i: Infon
   --------------------------------    Q: can the forall really only be an infon?
     G |- forall (x:t). i : Infon


    
                _____________
               |             |
               | i[u/x] = i' |  Definition of substitution
               |_____________|

  ------------
   x[u/x] = u
  
  ------------ (x != y)
   y[u/x] = y
  
  ------------
   c[u/x] = c
    
  ------------------------------------------
   (forall (x:t). i)[u/x] = forall (x:t). i
   
                i[u/x] = i'
  ------------------------------------------- (x != y)
   (forall (y:t). i)[u/x] = forall (y:t). i'
       
  --------------------
   Empty[u/x] = Empty   

  ------------------------------
   (AsInfon q)[u/x] = AsInfon q

   i[u/x] = i'   j[u/x] = j'
  ----------------------------
   (And i j)[u/x] = And i' j'

   i[u/x] = i'   j[u/x] = j'
  ------------------------------------
   (Implies i j)[u/x] = Implies i' j'
  
      p[u/x] = p'   i[u/x] = i'
  ------------------------------
   (Said p i)[u/x] = Said p' i'

   i[u/x] = i'   e[u/x] = e'
  ----------------------------------------
   (Justified i e)[u/x] = Justified i' e'

  
    
 TODO (capture avoiding subst. straightforward)
 
 

                _______________
               |               |
               | S; K; G |= i  |  Infon entailment in a substrate, infostrate, 
               |_______________|  and variable decl environment



 Well-formedness of a context:
     -- S is a set of closed relations
     -- K is a set of closed infons
     -- G is a set of unique bindings



  -------------------------- [Emp]  [ Q: Same as T? ] (logic axiom)
    S; K; G |= pref Empty


     i \in K
  ---------------- [Hyp-Knowledge]
    S; K; G |= i


    q \in S 
  ------------------------- [Hyp-Substrate]
    S; K; G |= AsInfon q


    S; K; G,x:t |= pref i
  ---------------------------------------- [Q-Intro]
    S; K; G |= pref (forall (x:t). i)


    S; K; G |= pref (forall (x:t). i)
          G |- u:t
  -------------------------------------- [Q-Inst]
    S; K; G |= pref (i [u/x])


    S; K; G |= pref (forall (x:t). i)
          G |- u:t
    y not in FreeNames G
  -------------------------------------- [Q-Inst]
    S; K; G |= pref (i[y/x][u/y])

    S; K; G |= pref i
    S; K; G |= pref j
  -------------------------- [And-Intro]
    S; K; G |= pref (And i j)


    S; K; G |= pref (And i j) 
  ------------------------- [And-Elim1]
    S; K; G |= pref i


    S; K; G |= pref (And i j) 
  --------------------------- [And-Elim2]
    S; K; G |= pref j


    S; K; G |= pref j
  ------------------------------- [W-Imp-Intro]
    S; K; G |= pref (Implies i j)


    S; K; G |= pref (Implies i j)
    S; K; G |= pref i
  ----------------------- [Imp-Elim]
    S; K; G |= pref j


    S; K; G |= pref (forall (x:t). i)
    y not in FreeVariables G
  -------------------------------------------- [Alpha]
    S; K; G |= pref (forall (y:t). i[y/x])



Justification?
